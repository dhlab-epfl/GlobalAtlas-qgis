

/*************************************************/
/* Table properties_types                        */
/*************************************************/

DROP TABLE IF EXISTS vtm.properties_types CASCADE;
CREATE TABLE vtm.properties_types
(
  id serial NOT NULL PRIMARY KEY,
  name text UNIQUE,
  creation_timestamp timestamp default now(),
  creation_user text default CURRENT_USER,
  modification_timestamp timestamp default now(),
  modification_user text default CURRENT_USER
);
INSERT INTO vtm.properties_types(id,name) VALUES (0,'geom');

CREATE TRIGGER properties_types_stamps BEFORE INSERT OR UPDATE ON vtm.properties_types FOR EACH ROW
    EXECUTE PROCEDURE vtm.stamp();

/*************************************************/
/* Table entity_types                            */
/*************************************************/

DROP TABLE IF EXISTS vtm.entity_types CASCADE;
CREATE TABLE vtm.entity_types
(
  id serial NOT NULL PRIMARY KEY,
  name text UNIQUE,
  min_zoom int,
  max_zoom int,
  zindex real,
  creation_timestamp timestamp default now(),
  creation_user text default CURRENT_USER,
  modification_timestamp timestamp default now(),
  modification_user text default CURRENT_USER
);
INSERT INTO vtm.entity_types(id,name,zindex) VALUES (0,'autogenerated',10000.0);

CREATE TRIGGER entity_types_stamps BEFORE INSERT OR UPDATE ON vtm.entity_types FOR EACH ROW
    EXECUTE PROCEDURE vtm.stamp();

/*************************************************/
/* Table entities                                */
/*************************************************/

DROP TABLE IF EXISTS vtm.entities CASCADE;
CREATE TABLE vtm.entities
(
  id serial NOT NULL PRIMARY KEY,
  name text,
  type_id integer NOT NULL REFERENCES vtm.entity_types ON DELETE CASCADE,
  creation_timestamp timestamp default now(),
  creation_user text default CURRENT_USER,
  modification_timestamp timestamp default now(),
  modification_user text default CURRENT_USER
);
COMMENT ON TABLE vtm.entities IS 'Cette table contient les entités historiques.';

CREATE TRIGGER entities_stamps BEFORE INSERT OR UPDATE ON vtm.entities FOR EACH ROW
    EXECUTE PROCEDURE vtm.stamp();



/*************************************************/
/* Table related_entities                        */
/*************************************************/

DROP TABLE IF EXISTS vtm.related_entities CASCADE;
CREATE TABLE vtm.related_entities
(
  id serial NOT NULL PRIMARY KEY,
  a_id integer NOT NULL REFERENCES vtm.entities ON DELETE CASCADE,
  b_id integer NOT NULL REFERENCES vtm.entities ON DELETE CASCADE,
  creation_timestamp timestamp default now(),
  creation_user text default CURRENT_USER,
  modification_timestamp timestamp default now(),
  modification_user text default CURRENT_USER
);
COMMENT ON TABLE vtm.related_entities IS 'Cette table contient les entités liées par une relation de succession.';

-- TRIGGER FOR STAMPS

CREATE TRIGGER related_entities_stamps BEFORE INSERT OR UPDATE ON vtm.related_entities FOR EACH ROW
    EXECUTE PROCEDURE vtm.stamp();

-- TRIGGER TO RECOMPUTE DATES

DROP FUNCTION IF EXISTS vtm.relations_reset_computed_dates();
/*
CREATE FUNCTION vtm.relations_reset_computed_dates() RETURNS trigger AS    
$$
    BEGIN

      IF TG_OP='INSERT' OR TG_OP='UPDATE' THEN
        PERFORM vtm.query_reset_computed_dates(NEW.a_id, NULL);
      END IF;
      
      IF TG_OP='UPDATE' OR TG_OP='DELETE' THEN
        PERFORM vtm.query_reset_computed_dates(OLD.a_id, NULL);
      END IF;       

      IF TG_OP='UPDATE' OR TG_OP='INSERT' THEN
        RETURN NEW;
      ELSE
        RETURN OLD;
      END IF;

    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER reset_date_for_relations AFTER INSERT OR UPDATE OF "a_id","b_id" OR DELETE ON vtm.related_entities FOR EACH ROW
    EXECUTE PROCEDURE vtm.relations_reset_computed_dates();
*/




/*************************************************/
/* Table sources                                 */
/*************************************************/

DROP TABLE IF EXISTS vtm.sources CASCADE;
CREATE TABLE vtm.sources
(
  id serial NOT NULL PRIMARY KEY,
  name text UNIQUE,
  creation_timestamp timestamp default now(),
  creation_user text default CURRENT_USER,
  modification_timestamp timestamp default now(),
  modification_user text default CURRENT_USER
);
COMMENT ON TABLE vtm.sources IS 'Cette table contient les documents sources.';

-- TRIGGER FOR STAMPS

CREATE TRIGGER sources_stamps BEFORE INSERT OR UPDATE ON vtm.sources FOR EACH ROW
    EXECUTE PROCEDURE vtm.stamp();


/*************************************************/
/* Table properties                              */
/*************************************************/

-- TABLE

DROP TABLE IF EXISTS vtm.properties CASCADE;
CREATE TABLE vtm.properties
(
  id serial NOT NULL PRIMARY KEY,
  entity_id integer NOT NULL REFERENCES vtm.entities ON DELETE CASCADE,
  description text,
  property_type_id integer NOT NULL REFERENCES vtm.properties_types ON DELETE CASCADE,
  value text,
  geovalue geometry(Geometry,4326),
  date integer,
  interpolation vtm.interpolation_type DEFAULT 'default', --TODO : NOT NULL
  computed_date_start integer,
  computed_date_end integer,
  --computed_size real,
  source_id integer REFERENCES vtm.sources ON DELETE SET NULL,
  source_description text,
  creation_timestamp timestamp default now(),
  creation_user text default CURRENT_USER,
  modification_timestamp timestamp default now(),
  modification_user text default CURRENT_USER
);
DROP FUNCTION IF EXISTS vtm.properties_stamps() CASCADE;

-- TRIGGER FOR STAMPS

CREATE TRIGGER properties_stamps BEFORE INSERT OR UPDATE ON vtm.properties FOR EACH ROW
    EXECUTE PROCEDURE vtm.stamp();


-- TRIGGER FOR GEOVALUE FIELD

DROP FUNCTION IF EXISTS vtm.manage_geovalue_field() CASCADE;
CREATE FUNCTION vtm.manage_geovalue_field() RETURNS trigger AS    
$$
    BEGIN
      IF TG_OP='INSERT' THEN

        IF NEW.geovalue IS NOT NULL THEN
          IF NEW.property_type_id IS NOT NULL AND NEW.property_type_id != 0 THEN
            RAISE EXCEPTION 'Key must be ''geom'' or NULL if a geovalue is provided !';
          END IF;
          NEW.property_type_id = 0;
          NEW.value = ST_AsText(NEW.geovalue);
          --NEW.computed_size = GREATEST(ST_XMax(NEW.geovalue)-ST_XMin(NEW.geovalue),ST_YMax(NEW.geovalue)-ST_YMin(NEW.geovalue));
        ELSIF NEW.property_type_id = 0 AND NEW.value IS NOT NULL THEN
          NEW.geovalue = ST_GeomFromText(NEW.value, 4326);
        END IF;
        RETURN NEW;

      ELSIF TG_OP='UPDATE' THEN

        IF NEW.property_type_id = 0 AND NEW.value != OLD.value AND (NEW.geovalue=OLD.geovalue OR (NEW.geovalue IS NULL AND OLD.geovalue IS NULL)) THEN
          NEW.geovalue = ST_GeometryFromText(NEW.value, 4326);
        END IF;

        IF NEW.geovalue IS NOT NULL THEN
          IF NEW.property_type_id IS NOT NULL AND NEW.property_type_id != 0 THEN
            RAISE EXCEPTION 'Key must be ''geom'' or NULL if a geovalue is provided !';
          END IF;
          NEW.property_type_id = 0;
          NEW.value = ST_AsText(NEW.geovalue);
          --NEW.computed_size = GREATEST(ST_XMax(NEW.geovalue)-ST_XMin(NEW.geovalue),ST_YMax(NEW.geovalue)-ST_YMin(NEW.geovalue));
        ELSIF NEW.property_type_id = 0 AND NEW.value IS NOT NULL THEN
          NEW.geovalue = ST_GeomFromText(NEW.value, 4326);
        END IF;
        RETURN NEW;

      ELSE
        RETURN NULL;      
      END IF;

    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER properties_i BEFORE INSERT OR UPDATE OF "property_type_id","geovalue","value" ON vtm.properties FOR EACH ROW
    EXECUTE PROCEDURE vtm.manage_geovalue_field();


-- TRIGGER TO CREATE AN ENTITY IF NONE IS PROVIDED

DROP FUNCTION IF EXISTS vtm.autogenerate_entity() CASCADE;

CREATE FUNCTION vtm.autogenerate_entity() RETURNS trigger AS    
$$
    DECLARE
        new_entity_id integer;
    BEGIN
        IF NEW.entity_id IS NULL THEN
          INSERT INTO "vtm"."entities"("name","type_id") VALUES ('entity_'||lpad(currval('vtm.entities_id_seq')::text,6,'0'), 0);
          NEW.entity_id = ( SELECT currval('vtm.entities_id_seq') );
        END IF;
        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER properties_bi BEFORE INSERT OR UPDATE OF entity_id ON vtm.properties FOR EACH ROW
    EXECUTE PROCEDURE vtm.autogenerate_entity();



-- TRIGGER TO RECOMPUTE DATES WHEN PROPERTIES ARE ADDED

/*
CREATE TRIGGER reset_date_for_properties AFTER INSERT OR UPDATE OF "date","property_type_id","entity_id" OR DELETE ON vtm.properties FOR EACH ROW
    EXECUTE PROCEDURE vtm.properties_reset_computed_dates();
*/

